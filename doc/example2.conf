# [General]
#
# First some information about the server.
# General {
#         name = "servername";
#         vhost = "ipv4vhost";
#         description = "description";
#         numeric = numericnumber;
# };
#
# <virtual host> must contain either a * or a valid IPv4 address in
# dotted quad notation. (127.0.0.1) The address MUST be the address
# of a physical interface on the host. This address is used for outgoing
# connections only, see Port blocks for listener virtual hosting.
# If in doubt put a * or the IP of your primary interface here.
# The server must be compiled with virtual hosting turned on to get this
# to work correctly.
#
# Note that <server numeric> has to be unique on the network your server
# is running on, must be between 0 and 4095, and is not updated on a rehash.
#
# Example:
#
# General {
#          name = "Amsterdam.NL.AfterNET.Org";
#          description = "Amsterdam AfterNET Server";
#          vhost = "*";
#          numeric = 1;
# };
#


# [Admin]
#
# This sets information that can be retrieved with the /ADMIN command.
# It should contain at least an admin Email contact address.
# Admin {
#   # At most two location lines are allowed...
#   Location = "Amsterdam";
#   Location = "AfterNET IRC server";
#   Contact = "IRC Admins <admins@afternet.org>";
# };
#


# [CRule]
#
# For an advanced, real-time rule-based routing decision making system
# you can use crule blocks. For more information, see doc/readme.crules.
# Including the "all" modifier makes the rule always apply.  Otherwise
# it only applies to outbound autoconnects.
#
# CRule "servermask" all connectrule;
# CRule "servermask" connectrule;
#
# Examples:
#
# CRule "*.US.AfterNET.Org" connected("*.US.AfterNET.Org");
# CRule "*.EU.AfterNET.Org" connected("Amsterdam.NL.EU.*");
#
# The following CRule is recommended for leaf servers:
# CRule "*" directcon("*");
#


# [UWorld]
#
# One of the many nice features in Nefarious is "Uworld", a program
# connected to the net as a server. This allows it to broadcast any mode
# change, thus allowing opers to, for example, "unlock" a channel that
# has been taken over.
# There is only one slight problem: the TimeStamp protocol prevents this.
# So there is a configuration option to allow them anyway from a certain
# server.
#
# UWorld {
#  # The servername or wildcard mask for it that this applies to.
#  name = "relservername";
# };
#
# You may have have more than one name listed in each block.
#
# Note: (1) These lines are agreed on by every server admin;
# (2) These lines must be the same on every single server, or results
# will be disasterous; (3) This is a useful feature, not something that
# is a liability and abused regularly (well... :-)
#
# If your server starts on a bit larger network, you'll probably get
# assigned one or two uplinks to which your server can connect.
# If your uplink(s) also connect to other servers than yours (which is
# probable), you need to define your uplink as being allowed to "hub".
# See the Connect block documentation for details on how to do that.
#
# Examples:
#
# UWorld {
#  name = "uworld.eu.undernet.org";
#  name = "uworld2.undernet.org";
#  name = "uworld.undernet.org";
#  name = "channels.undernet.org";
#  name = "channels2.undernet.org";
#  name = "channels3.undernet.org";
#  name = "channels4.undernet.org";
#  name = "channels5.undernet.org";
#  name = "channels6.undernet.org";
# };
#
# As of ircu2.10.05 is it possible to Jupe nicks. As per CFV-0095 and
# CFV-0255, the following nicks must be juped, it is not allowed to
# jupe others as well.
#
# Examples:
#
# Jupe {
#  nick = "A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,{,|,},~,-,_,`";
#  nick = "EuWorld,UWorld,UWorld2";
#  nick = "login,undernet,protocol,pass,newpass,org";
#  nick = "StatServ,NoteServ";
#  nick = "ChanSvr,ChanSaver,ChanServ";
#  nick = "NickSvr,NickSaver,NickServ";
#  nick = "LPT1,LPT2,COM1,COM2,COM3,COM4,AUX";
#  nick = "X3,O3,MemoServ";
# };
#


# [Kill]
#
# While running your server, you will most probably encounter individuals
# or groups of persons that you do not wish to have access to your server.
#
# For this purpose, the ircd understands "kill blocks". These are also
# known as K-lines, by virtue of the former config file format.
# Kill
# {
#   host = "user@host";
#   reason = "The reason the user will see";
# };
# It is possible to ban on the basis of the real name.
# It is also possible to use a file as comment for the ban, using
# file = "file":
# Kill
# {
#   realname = "realnametoban";
#   file = "path/to/file/with/reason/to/show";
# };
#
#
# The default reason is: "You are banned from this server"
# Note that Kill blocks are local to the server; if you ban a person or a
# whole domain from your server, they can get on IRC via any other server
# that doesn't have them Killed (yet).
#
# With a simple comment, using quotes:
#
# Kill { host = "*.au"; reason = "Please use a nearer server"; };
# Kill { host = "*.edu"; reason = "Please use a nearer server"; };
# 
# You can also kill based on username.
# Kill { username = "sub7"; realname = "s*7*"; reason = "You are infected with a Trojan"; };
# 
# The file can contain for example, a reason, a link to the
# server rules and a contact address.  Note the combination
# of username and host in the host field.
#
# Kill
# {
#  host = "*luser@unixbox.flooder.co.uk";
#  file = "kline/youflooded.txt";
# };
# 
# IP-based kill lines apply to all hosts, even if an IP address has a
# properly resolving host name.
#
# Kill
# {
#  host = "192.168.*";
#  file = "klines/martians";
# };
# 
# The realname field lets you ban by realname...
#
# Kill
# {
#  realname = "*sub7*";
#  reason = "You are infected with a Trojan";
# };
# 
# Additionally, you may specify a hostmask prefixed with $V to indicate
# a match should be performed against the CTCP version of the user rather
# than the host/IP.
#
# Kill
# {
#  version = "*iroffer*";
#  reason = "You are using a disallowed chat client version. Either upgrade or get a new client.";
# };
#

 
# [Except]
#
# These can be used to exempt a user from Kill Blocks, GLINE's, ZLINE's and
# SHUN's
#
# The syntax for Except blocks is:
#
# Except {
#   mask = "<mask>";
#   flags = "<flags>";
#
# <mask>  is a ident@ip/host/cidr mask that is to match the user to be
#         exempted
# <flags> is oone of the following flags to specify what the exempt is to
#         match
#
# k       Excpet affecks K/k:Lines
# g       Except affects GLINE's
# z       Except affects ZLINE's
# s       Except affects SHUN's
#
# Example:
#
# Except {
#   mask = "*@*.afternet.org";
#   flags = "kgzs";
# };
#


# [Command]
#
# These are lines intended to improve the generic irc users ability to
# use network services. Each line sets up a /<service> alias so that
# users may type that instead of a full /msg command.
#
# for example.. adding:
## Command {
##   cmd = "X2";
##   service = "X2@X2.AfterNET.Services";
##   prefix = "";
## };
# would result in commands like this being possible
## /X2 HELP
#
# Command {
#   cmd = "<name of command/service>";
#   service = "<target>";
#   prefix = "<anything to prepend to message>";
# };
#


# [Forward]
# These blocks will enable the server to forward any messages which
# are prefixed and specific with a b:line. This will allow users to
# use the services without the services being in channel.
#
# Forward {
#   "<prefix>" = "<server>";
# };
#
# Forward {
#   "!" = "services.network.org";
#   "?" = "services.network.org";
# };
#
# Any channel messages prefixed with a ? or a ! would be sent to
# services.network.org in the above examples.


# [Redirect]
#
# These are redirection lines, when a client connects and his/her host
# matches a q:line then a 010 reply is sent with the redir server and
# port.
#
# Redirect {
#   mask = "<mask>";
#   server = "<redirection server>";
#   port = "<redirection port>";
# };
#
#
# Redirect {
#   mask = "*.aol.com";
#   server = "irc.aol.com";
#   port = "6667";
# };
#


# [Spoofhost]
#
# Spoofhost {
#   spoof = "<spoof host>";
#   pass = "<password>";
#   hostmask = "<*.host.cc|a.b.c.*|CIDR>";
#   ident = "<ident>";
# };
#
# <spoof>       A hostname to be spoofed
# <password>    A password for this spoof host. Used if SETHOST_USER is enabled.
# <hostmask>    A hostmask for matching against users that are to be auto
#               spoofed. Used if SETHOST_AUTO is enabled. Can be of form:
#               host.domain.cc, 127.0.0.1 or 127.0.0.0/24, supports wildcards
#               for non-CIDR.
# <ident>       A mask for matching against the user's ident reply.
#


# [Quarantine]
#
# This allows you (the admin) to disallow the usage of /OPMODE and
# /CLEARMODE on certain sensitive channels. Opers trying to do that
# will receive a short notice. Depending on the setting of
# OPER_FORCE_OPMODE, OPER_FORCE_LOPMODE and LOCOP_FORCE_LOPMODE,
# global/local opers may override these lines by prefixing the
# channel name with an exclamation mark ('!')
#
# Quarantine {
#   "#shells" = "Thou shalt not support the h4><0rz";
#   "&kiddies" = "They can take care of themselves";
# };
#


# [DNSBL]
#
# This allows you (the admin) to prevent clients connecting who are listed
# on DNS blacklists. Their connection will be rejected during the connection
# process along with the name and url you give for the DNSBL they have
# been matched on.
#
# DNSBL {
#   server = "<dnsbl.site.org>";
#   name = "<name>";
#   flags = "<flags>";
#   replies = "<replies/mask>";
#   reply = "<rejection message>";
#   rank = "<rank>";
# }
#
#
# Flags:
#
# Bitmask DNSBL:  b - See your DNSBL provider as to if you should use this or not.
# Reply DNSBL:    r - See your DNSBL provider as to if you should use this or not, this
#                     type is normally the default type for most DNSBL's.
# Allow Connect:  a - Allow the client to connect anyway. This could be used with a
#                     DNSBL whitelist. This could also be used to allow people in but
#                     mark their hosts so that channel ops can choose weather they want
#                     them in thier channel or not.
# Deny Connect:   d - If the user is found on this dnsbl then they cant connect, even if
#                     they are allowed on another X:Line.
# Mark Hostname:  m - Mark the hostname of a skipped client.
#
# 
# The name option is used for the Mark hostname flag, this must contain hostname
# valid characters only, ie NO spaces. With REPLY DNSBL's you need to list the
# replies in a comma seperate list. See below for an example. With BITMASK DNSBL's
# just again specify the replies you need to match against. The server will sum
# them up and match them against the DNSBL reply. It is highly recomended that
# you place the rejection message in "quotes". Rejection messages are limited
# in length, currently they cant be all that long but that is being worked on. The
# rejected users nick, username, ip, and host can be placed into the rejection
# message by using these codes:
#
# %n - Nickname
# %u - Username
# %h - Hostname
# %i - IP Address
#
# The rank number must be unique over all DNSBL blocks, the higher the number- the more
# rank it has. The highest ranking DNSBL block which is matched against a user will
# get its name marked in the hostname.
#
# Example:
#
# DNSBL {
#   server = "dnsbl.sorbs.net";
#   name = "sorbs.net";
#   flags = "r";
#   replies = "1,2,3,4";
#   reply = "%n!%u@%h Found On Sorbs DNSBL http://www.dnsbl.us.sorbs.net/cgi-bin/lookup?IP=%i";
#   rank = "1";
# }
#
# This will reject clients who get a return addresses of 1,3 and 4 off
# dnsbl.sorbs.net. Sample rejection message:
#
# "bloggs!someident@google.com Found On Sorbs DNSBL http://www.dnsbl.us.sorbs.net/cgi-bin/lookup?IP=111.222.111.222"
#
# BITMASK Example:
#
# DNSBL {
#   server = "dnsbl.dnsbl.net";
#   name = "dnsbl.net";
#   flags = "b";
#   replies = "1,3,5";
#   reply = "%n!%u@%h Found On DNSBL";
#   rank = "2";
# };
#
# I reccomend you take advantage of ircd.conf includes and list your X:Lines in
# a seperate file as it could be quite a large list.
#
# Notes: MAKE SURE you read the DNSBL website before you go ahead and use it
# as they may have rules for large sites/servers who use them. If you do not
# wish to use DNSBL checking then simply do not set any X:lines. I only
# reccomend that you use one DNSBL, due to the amount of time it will take to
# connect with multiple DNSBL's.


# [WebIRC]
#
# These blocks allow you to run a CGI:IRC client on your website without
# having to set clone exceptions for your websites hostname on your IRCd.
# CGI:IRC will send a WEBIRC command along with the clients hostname, ip and
# W:Line password. The password needs to be encrypted like O:line passwords.
# When the IRCd recieves the command instead of using the hostname of the IRCd
# the hostname sent in WEBIRC will be set. All this is done before the client
# enters the network completly. Please rememeber to enclose the description
# using quotes otherwise things will break.
#
# Available Flags:
# m - Marks each client connected via the W:line using the provided description.
# s - Sets the ident specified in the ident field for each WEBIRC client.
# u - Uses the ident from USER that the WEBIRC client sends.
#
# Note: Do not use both s and u, only choose one of them.
#
#
# WebIRC {
#   mask = "*@afternet.org";
#   pass = "VRKLKuGKn0jLs";
#   flags = "sm";
#   ident = "cgiirc";
#   desc = "AfterNET CGI:IRC";
# };
#


# [Filter]
#
# These blocks allow you to filter PRIVMSG's, NOTICE's, TOPIC's and AWAY's for
# Spam. The filtering is doing using regular expressions so please be careful.
#
# Filter {
#   name = "<regex>";
#   rtype = "<watch flags>";
#   action = "<action flags>";
#   reason = "<reason>";
# };
#
# Available Watch Flags
# n - Notices.
# N - Channel Notices.
# p - Privmsgs.
# C - Channel Privmsgs.
# q - Quits.
# p - Parts.
# d - DCCs.
# a - Away messages.
# t - Topics.
# u - Connects (nick!user@host:gecos).
#
# Available Action Flags
# a - Auth, if added logged in clients will be exempt from the filter.
# C - Channel Alert, if added filter matches will be sent to the Feature set for
#     FILTER_ALERT_CHANNAME.
# S - Server Alert
# k - Kill, will kill anyone who matches the filter line.
# g - Gline, will gline anyone who matches the filter line. The length can be set
#     in seconds via the Feature FILTER_GLINE_LENGTH
# z - Zline, will zline anyone who matches the filter line. The length can be set
#     in seconds via the Feature FILTER_ZLINE_LENGTH
# s - Shun, will shun anyone who matches the filter line. The length can be set
#     in seconds via the Feature FILTER_SHUN_LENGTH
# b - Block, will stop the PRIVMSG/NOTICE/TOPIC/AWAY from going through.
# n - Notify, will notify the person matching the filter line saying they have
#     matched a filter line and the message has been denyed.
#
# Notes:
# Shuns and Glines will be set using *@hostname
#


# [Port]
#
# When your server gets more full, you will notice delays when trying to
# connect to your server's primary listening port. It is possible via the
# Port lines to specify additional ports for the ircd to listen to.
# De facto ports are: 6667 - standard; 6660-6669 - additional client
# ports;
# Undernet uses 4400 for server listener ports.
# These are just hints, they are in no way official IANA or IETF policies.
# IANA says we should use port 194, but that requires us to run as root,
# so we don't do that.
#
#
# Port {
#  port = number;
#  mask = "ipmask";
#  # Use this to control the interface you bind to.
#  vhost = "virtualhostip";
#  # Setting to yes makes this server only.
#  server = yes;
#  # Setting to yes makes the port "hidden" from stats.
#  hidden = yes;
#  # Setting to yes makes the port accept SSL connections from clients.
#  ssl = yes;
#  # Setting to yes makes the port exempt from connection restrictions
#  # during a timed /restart or /die.
#  exempt = yes;
# };
#
# The mask setting allows you to specify a range of IP addresses that
# you will allow connections from. This should only contain IP addresses
# and '*' if used. This field only uses IP addresses. This does not use
# DNS in any way so you can't use it to allow *.nl or *.uk. Attempting
# to specify anything other than numbers, dots and stars [0-9.*] will result
# in the port allowing connections from anyone.
#
# The interface setting allows multiply homed hosts to specify which
# interface to use on a port by port basis, if an interface is not specified
# the default interface will be used. The interface MUST be the complete
# IP address for a real hardware interface on the machine running ircd.
# If you want to use virtual hosting *YOU* *MUST* *USE* *THIS* otherwise it
# WILL bind to all interfaces - not what most people seem to expect.
#
# Examples:
#
# Port {
#  server = yes;
#  port = 4400;
# };
#
# The following are normal client ports
# Port { port = 6667; };
# Port { port = 6668; };
# Port {
#  # This only accepts clients with IPs like 192.168.*.
#  mask = "192.168.*";
#  port = 6666;
#  # Allows your opers to connect during a timed /restart or /die.
#  exempt = yes;
# };
#
# This is a hidden client port, listening on 168.8.21.107.
# Port {
#  vhost = "168.8.21.107";
#  hidden = yes;
#  port = 7000;
# };
#


# [Include]
# You can include certain kinds of configuration snippets from other
# files.  The basic directive, which allows any kind of block or
# recursive include, is:
#
#   Include "filename";
#
# You can limit the file to certain types of configuration blocks by
# using the block name(s), optionally separated by commas.  For
# example:
#
#   Include uworld, jupe, quarantine, kill from "linesync.conf";
#   Include operator from "opers.conf";
#   Include include from "include.conf";
#
# The restrictions are transitive across includes.  This means that
# the last example is not very useful: the only thing include.conf may
# do is include other include files, and none of them may have any
# other kind of block!
#
# Well-formed but disallowed configuration blocks generate a warning
# but do not break the file.  The other syntax rules must still be
# followed, because a syntax error will break the file.


# [Features]
#
# IRC servers have a large number of options and features.  Most of these
# are set at compile time through the use of #define's--see "make config"
# for more details--but we are working to move many of these into the
# configuration file.  Features let you configure these at runtime.
# You only need one feature block in which you use
# "featurename" = "value1" , "value2", ..., "valuen-1", "valuen";
#
# The entire purpose of Features are so that you do not have to recompile
# the IRCD everytime you want to change a feature.  All of the features
# are listed below, and at the bottom is how to set logging.
#
# A Special Thanks to Kev for writing the documentation of F:lines.  It can
# be found at doc/readme.features and the logging documentation can be
# found at doc/readme.log.  The defaults used by the Undernet network are
# below.
#
Features
{
# These log features are the only way to get certain error messages
# (such as when the server dies from being out of memory).  For more
# explanation of how they work, see doc/readme.log.
 "LOG" = "SYSTEM" "FILE" "ircd.log";
 "LOG" = "SYSTEM" "LEVEL" "CRIT";
#
# Server Settings
#
#  "DOMAINNAME" = "<obtained from /etc/resolv.conf by ./configure>";
#  "RELIABLE_CLOCK" = "FALSE";
#  "BUFFERPOOL" = "27000000";
#  "HAS_FERGUSON_FLUSHER" = "FALSE";
#  "CLIENT_FLOOD" = "1024";
#  "SERVER_PORT" = "4400";
#  "NODEFAULTMOTD" = "TRUE";
#  "MOTD_BANNER="TRUE";
#  "KILL_IPMISMATCH" = "FALSE";
#  "IDLE_FROM_MSG" = "TRUE";
#  "HUB" = "FALSE";
#  "WALLOPS_OPER_ONLY" = "FALSE";
#  "NODNS" = "FALSE";
#  "RANDOM_SEED" = "<you should set one explicitly>";
#  "DEFAULT_LIST_PARAM" = "TRUE";
#  "NICKNAMEHISTORYLENGTH" = "800";
#  "TIME_IN_TIMEOUT" = "FALSE";
#  "KILLCHASETIMELIMIT" = "30";
#  "MAXCHANNELSPERUSER" = "10";
#  "AVEXCEPTLEN" = "40";
#  "MAXEXCEPTS" = "45";
#  "NICKLEN" = "15";
#  "CHANNELLEN" = "200";
#  "AVBANLEN" = "40";
#  "MAXBANS" = "45";
#  "MAXSILES" = "15";
#  "HANGONGOODLINK" = "300";
#  "HANGONRETRYDELAY" = "10";
#  "CONNECTTIMEOUT" = "90";
#  "TIMESEC" = "60";
#  "MAXIMUM_LINKS" = "1";
#  "PINGFREQUENCY" = "120";
#  "CONNECTFREQUENCY" = "600";
#  "DEFAULTMAXSENDQLENGTH" = "40000";
#  "SHUNMAXUSERCOUNT" = "20";
#  "GLINEMAXUSERCOUNT" = "20";
#  "MPATH" = "ircd.motd";
#  "QPATH" = "ircd.quotes";
#  "EPATH" = "ircd.rules";
#  "OMPATH" = "ircd.opermotd";
#  "RPATH" = "remote.motd";
#  "PPATH" = "ircd.pid";
#  "TPATH" = "ircd.tune";
#  "VIRTUAL_HOST" = "FALSE";
#  "TOS_SERVER" = "0x08";
#  "TOS_CLIENT" = "0x08";
#  "POLLS_PER_LOOP" = "200";
#  "IRCD_RES_TIMEOUT" = "4";
#  "IRCD_RES_RETRIES" = "2";
#  "AUTH_TIMEOUT" = "9";
#  "NICK_DELAY" = "30";
#  "POLICY_NOTICE" = "TRUE";
#  "TARGET_LIMITING" = "TRUE";
#  "EXTENDED_ACCOUNTS" = "TRUE";
#  "NETWORK_REHASH" = "FALSE";
#  "NETWORK_RESTART" = "FALSE";
#  "NETWORK_DIE" = "FALSE";
#  "HELP_PACE" = "5";

#
# Commands
#
#  "QUOTES" = "TRUE";
#  "RULES" = "TRUE";
#  "OPERMOTD" = "TRUE";

#
#  Spam Filter Settings
#
#  "FILTER_ALERT_CHANNAME" = "#opers";
#  "FILTER_ALERT_USEMSG" = "FALSE";
#  "FILTER_GLINE_LENGTH" = "3600";
#  "FILTER_ZLINE_LENGTH" = "3600";
#  "FILTER_SHUN_LENGTH" = "3600";

#
# Login On Connect
#
#  "LOGIN_ON_CONNECT" = "FALSE";
#  "LOC_DEFAULT_SERVICE" = "authserv";

#
# User Modes
#
#  "DEFAULT_UMODE" = "+";

#
# Hidden Hosts Settings
#
#  "HOST_HIDING" = "TRUE";
#  "HOST_HIDING_STYLE" = "1";
#  "HOST_HIDING_KEY1" = "aoAr1HnR6gl3sJ7hVz4Zb7x4YwpW";
#  "HOST_HIDING_KEY2" = "sdfjkLJKHlkjdkfjsdklfjlkjKLJ";
#  "HOST_HIDING_KEY3" = "KJklJSDFLkjLKDFJSLKjlKJFlkjS";
#  "HOST_HIDING_PREFIX" = "AfterNET";
#  "OPERHOST_HIDING" = "TRUE";
#  "HIDDEN_HOST" = "Users.AfterNET.Org";
#  "HIDDEN_OPERHOST" = "Opers.AfterNET.Org";
#  "HIDDEN_IP" = "127.0.0.1";

# Autojoin Settings
#
# ALWAYS PREFIX HASHES WITH A BACKSLASH IN AUTOJOIN FEATURES!
#
#  "AUTOJOIN_USER" = "FALSE";
#  "AUTOJOIN_USER_CHANNEL" = "\#evilnet";
#  "AUTOJOIN_USER_NOTICE" = "TRUE";
#  "AUTOJOIN_USER_NOTICE_VALUE" = "*** Notice -- You are now being autojoined into \#evilnet";
#  "AUTOJOIN_ADMIN" = "FALSE";
#  "AUTOJOIN_ADMIN_CHANNEL" = "\#admin";
#  "AUTOJOIN_ADMIN_NOTICE" = "TRUE";
#  "AUTOJOIN_ADMIN_NOTICE_VALUE" = "*** Notice -- You are now being autojoined into admin channel \#admin";
#  "AUTOJOIN_OPER" = "FALSE";
#  "AUTOJOIN_OPER_CHANNEL" = "\#opers";
#  "AUTOJOIN_OPER_NOTICE" = "TRUE";
#  "AUTOJOIN_OPER_NOTICE_VALUE" = "*** Notice -- You are now being autojoined into oper channel \#opers";

#
# Oper Settings
#
#  "OPER_WHOIS_SECRET" = "TRUE";
#  "CRYPT_OPER_PASSWORD" = "TRUE";
#  "OPER_NO_CHAN_LIMIT" = "TRUE";
#  "OPER_MODE_LCHAN" = "TRUE";
#  "OPER_WALK_THROUGH_LMODES" = "FALSE";
#  "NO_OPER_DEOP_LCHAN" = "FALSE";
#  "SHOW_INVISIBLE_USERS" = "TRUE";
#  "SHOW_ALL_INVISIBLE_USERS" = "TRUE";
#  "UNLIMIT_OPER_QUERY" = "FALSE";
#  "REMOTE_OPER" = "FALSE";
#  "LOCAL_KILL_ONLY" = "FALSE";
#  "CHECK_EXTENDED" = "TRUE";
#  "MAX_CHECK_OUTPUT" = "1000";
#  "CONFIG_OPERCMDS" = "FALSE";
#  "OPERFLAGS" = "FALSE";
#  "CONNEXIT_NOTICES" = "FALSE";

#
# WHOIS Settings
#
#  "WHOIS_OPER" = "is an IRC Operator";
#  "WHOIS_ADMIN" = "is an IRC Administrator";
#  "WHOIS_SERVICE" = "is a Network Service";

#
# ALIST Settings
#
#  "SET_ACTIVE_ON_CREATE" = "TRUE";
#  "DEF_ALIST_LIMIT" = "30";
#  "ALIST_SEND_FREQ" = "300";
#  "ALIST_SEND_DIFF" = "600";

#
# SETHOST Settings
#
#  "SETHOST" = "TRUE";
#  "SETHOST_USER" = "TRUE";
#  "SETHOST_AUTO" = "TRUE";
#  "SETHOST_FREEFORM" = "FALSE";

#
# Channel Settings
#
#  "TOPIC_BURST" = "TRUE";
#  "HOST_IN_TOPIC" = "TRUE";
#  "AUTOCHANMODES" = "FALSE";
#  "AUTOCHANMODES_LIST" = "nt";
#  "LOCAL_CHANNELS" = "TRUE";
#  "EXCEPTS" = "FALSE";
#  "BREAK_P10" = "FALSE";
#  "FLEXABLEKEYS" = "FALSE";
#  "NOTHROTTLE" = "FALSE";
#  "CREATE_CHAN_OPER_ONLY" = "FALSE";
#  "ANNOUNCE_INVITES" = "TRUE";
#  "HALFOPS" = "FALSE";
#  "BADCHAN_REASON" = "This Channel Has Been Banned";

#
# Global Oper Permissions
#
#  "OPER_KILL" = "TRUE";
#  "OPER_REHASH" = "TRUE";
#  "OPER_RESTART" = "TRUE";
#  "OPER_DIE" = "TRUE";
#  "OPER_SHUN" = "TRUE";
#  "OPER_LSHUN" = "TRUE";
#  "OPER_GLINE" = "TRUE";
#  "OPER_LGLINE" = "TRUE";
#  "OPER_JUPE" = "TRUE";
#  "OPER_LJUPE" = "TRUE";
#  "OPER_OPMODE" = "TRUE";
#  "OPER_LOPMODE" = "TRUE";
#  "OPER_FORCE_OPMODE" = "TRUE";
#  "OPER_FORCE_LOPMODE" = "TRUE";
#  "OPER_BADCHAN" = "FALSE";
#  "OPER_LBADCHAN" = "FALSE";
#  "OPER_SET" = "FALSE";
#  "OPERS_SEE_IN_SECRET_CHANNELS" = "TRUE";
#  "OPER_WIDE_SHUN" = "TRUE";
#  "OPER_WIDE_GLINE" = "TRUE";

#
# Local Oper Permissions
#
#  "LOCOP_KILL" = "TRUE";
#  "LOCOP_REHASH" = "TRUE";
#  "LOCOP_RESTART" = "FALSE";
#  "LOCOP_DIE" = "FALSE";
#  "LOCOP_LSHUN" = "TRUE";
#  "LOCOP_LGLINE" = "TRUE";
#  "LOCOP_LJUPE" = "TRUE";
#  "LOCOP_LOPMODE" = "TRUE";
#  "LOCOP_FORCE_LOPMODE" = "TRUE";
#  "LOCOP_LBADCHAN" = "FALSE";
#  "LOCOP_SET" = "FALSE";
#  "LOCOP_SEE_IN_SECRET_CHANNELS" = "FALSE";
#  "LOCOP_WIDE_SHUN" = "FALSE";
#  "LOCOP_WIDE_GLINE" = "FALSE";

#
# Server Passwords
#
#  "RESTARTPASS" = "";
#  "DIEPASS" = "";

#
# DNSBL Checks
#
#  "DNSBL_CHECKS" = "FALSE";
#  "DNSBL_EXEMPT_CLASS" = "0";
#  "DNSBL_LOC_EXEMPT" = "FALSE";
#  "DNSBL_LOC_EXEMPT_N_ONE" = "If you have an account with %s services then you can bypass the dnsbl ban by logging in like this" = " (where Account is your account name and Password is your password.";
#  "DNSBL_LOC_EXEMPT_N_TWO" = "Type \002/QUOTE PASS AuthServ Account " = "Password\002 to connect";
#  "EXEMPT_EXPIRE" = "172800";
#  "DNSBL_MARK_FAKEHOST" = "TRUE";

#
# CTCP Version Checks
#
#  "CTCP_VERSIONING" = "FALSE";
#  "CTCP_VERSIONING_KILL" = "FALSE";
#  "CTCP_VERSIONING_CHAN" = "FALSE";
#  "CTCP_VERSIONING_CHANNAME" = "#opers"
#  "CTCP_VERSIONING_USEMSG" = "FALSE";
#  "CTCP_VERSIONING_NOTICE" = "*** Checking your client version";

#
# Raw Replies
#
#  "ERR_OPERONLYCHAN" = "Cannot join channel (+O)";

#
# Server Security Settings
#
#  "HIS_EXCEPTWHO" = "TRUE";
#  "HIS_IRCOPS" = "TRUE";
#  "HIS_IRCOPS_SERVERS" = "TRUE";
#  "HIS_MAP" = "TRUE";
#  "HIS_MAP_SCRAMBLED" = "TRUE";
#  "HIS_SNOTICES" = "TRUE";
#  "HIS_SNOTICES_OPER_ONLY" = "TRUE";
#  "HIS_SNOTICES_OPER_AND_BOT" = "FALSE";
#  "HIS_DESYNCS" = "TRUE";
#  "HIS_DEBUG_OPER_ONLY" = "TRUE";
#  "HIS_WALLOPS" = "TRUE";
#  "HIS_LINKS" = "TRUE";
#  "HIS_LINKS_SCRAMBLED" = "TRUE";
#  "HIS_TRACE" = "TRUE";
#  "HIS_SHUN_REASON" = "TRUE";
#  "HIS_STATS_l" = "TRUE";
#  "HIS_STATS_B" = "TRUE";
#  "HIS_STATS_b" = "TRUE";
#  "HIS_STATS_c" = "TRUE";
#  "HIS_STATS_g" = "TRUE";
#  "HIS_STATS_h" = "TRUE";
#  "HIS_STATS_k" = "TRUE";
#  "HIS_STATS_f" = "TRUE";
#  "HIS_STATS_i" = "TRUE";
#  "HIS_STATS_j" = "TRUE";
#  "HIS_STATS_M" = "TRUE";
#  "HIS_STATS_m" = "TRUE";
#  "HIS_STATS_o" = "TRUE";
#  "HIS_STATS_p" = "TRUE";
#  "HIS_STATS_q" = "TRUE";
#  "HIS_STATS_R" = "TRUE";
#  "HIS_STATS_r" = "TRUE";
#  "HIS_STATS_d" = "TRUE";
#  "HIS_STATS_E" = "TRUE";
#  "HIS_STATS_e" = "TRUE";
#  "HIS_STATS_s" = "TRUE";
#  "HIS_STATS_t" = "TRUE";
#  "HIS_STATS_T" = "TRUE";
#  "HIS_STATS_u" = "FALSE";
#  "HIS_STATS_U" = "TRUE";
#  "HIS_STATS_v" = "TRUE";
#  "HIS_STATS_W" = "TRUE";
#  "HIS_STATS_w" = "FALSE";
#  "HIS_STATS_x" = "TRUE";
#  "HIS_STATS_X" = "TRUE";
#  "HIS_STATS_y" = "TRUE";
#  "HIS_STATS_z" = "TRUE";
#  "HIS_WHOIS_SERVERNAME" = "TRUE";
#  "HIS_WHOIS_IDLETIME" = "TRUE";
#  "HIS_WHOIS_LOCALCHAN" = "TRUE";
#  "HIS_WHO_SERVERNAME" = "TRUE";
#  "HIS_WHO_HOPCOUNT" = "TRUE";
#  "HIS_BANWHO" = "TRUE";
#  "HIS_KILLWHO" = "TRUE";
#  "HIS_HIDEWHO" = "TRUE";
#  "HIS_REWRITE" = "TRUE";
#  "HIS_REMOTE" = "1";
#  "HIS_SCRAMBLED_CACHE_TIME" = "604800";
#  "HIS_NETSPLIT" = "TRUE";
#  "HIS_SHUN" = "TRUE";
#  "HIS_GLINE" = "TRUE";
#  "HIS_SERVERNAME" = "*.Nefarious";
#  "HIS_SERVERINFO" = "evilnet development";
#  "HIS_URLSERVERS" = "http" = "//sourceforge.net/projects/evilnet/";
#  "NETWORK" = "Nefarious";
#  "URL_CLIENTS" = "http" = "//www.ircreviews.org/clients/";
#  "BADUSER_URL" = "http" = "//www.mirc.co.uk/help/servererrors.html";
};
