# ircd.conf  configuration file for Nefarious IRCu 1.3.0
#
# Last Updated:  4, October 2008.
#
# Written originaly by Niels <niels@undernet.org>, updated by the 
# Nefarious IRCu team.
#
# Updated and heavily modified by Braden <dbtem@yahoo.com>.
#
# Thanks and credits to: Run, Trillian, Cym, Morrissey, Chaos, Flynn,
#                        Xorath, WildThang, Mmmm, SeKs, Ghostwolf and
#                        all other Undernet IRC Admins and Operators,
#                        and programmers working on the Undernet ircd.
#
# This is an example of the configuration file used by Nefarious IRCu.
#
# The configuration format consists of a number of blocks in the format
#  BlockName { setting = number; setting2 = "string"; setting3 = yes; };
# Note that comments start from a #(hash) and go to the end of the line.
# Whitespace(space, tab, or carriage return/linefeed) are ignored and may
# be used to make the configuration file more readable.
#
# Please note that when ircd puts the configuration lines into practice,
# it parses them exactly the other way round than they are listed here.
# It uses the blocks in reverse order.
#
# This means that you should start your Client blocks with the
# "fall through", most vanilla one, and end with the most detailed.
#
# There is a difference between the "hostname" and the "server name"
# of the machine that the server is run on. For example, the host can
# have "veer.cs.vu.nl" as FQDN, and "Amsterdam.EU.AfterNET.ORG" as
# server name.
# A "server mask" is something like "*.EU.AfterNET.Org", which is
# matched by "Amsterdam.EU.AfterNET.ORG" but not by
# "Pyro.US.AfterNET.Org".
#
# Please do NOT just rename the example.conf to ircd.conf and expect
# it to work.


# [General]
#
# First some information about the server.
# General {
#         name = "servername";
#         vhost = "ipv4vhost";
#         description = "description";
#         numeric = numericnumber;
# };
#
# <virtual host> must contain either a * or a valid IPv4 address in
# dotted quad notation. (127.0.0.1) The address MUST be the address
# of a physical interface on the host. This address is used for outgoing
# connections only, see Port blocks for listener virtual hosting.
# If in doubt put a * or the IP of your primary interface here.
# The server must be compiled with virtual hosting turned on to get this
# to work correctly.
#
# Note that <server numeric> has to be unique on the network your server
# is running on, must be between 0 and 4095, and is not updated on a rehash.
#
# Example:
#

General {
         name = "Amsterdam.EU.AfterNET.Org";
         description = "Amsterdam AfterNET Server";
         vhost = "*";
         numeric = 1;
};


# [Admin]
#
# This sets information that can be retrieved with the /ADMIN command.
# It should contain at least an admin Email contact address.

Admin {
  # At most two location lines are allowed...
  Location = "Amsterdam";
  Location = "AfterNET IRC server";
  Contact = "IRC Admins <admins@afternet.org>";
};


# [Classes]
#
# All connections to the server are associated with a certain "connection
# class", be they incoming or outgoing (initiated by the server), be they
# clients or servers.
#
# Class {
#  name = class;
#  pingfreq = time;
#  connectfreq = time;
#  maxlinks = number;
#  sendq = size;
#  usermode = "+i";
# };
#
# For connection classes used on server links, maxlinks should be set
# to either 0 (for hubs) or 1 (for leaf servers).  Client connection
# classes may use maxlinks between 0 and approximately 4,000,000,000.
# maxlinks = 0 means there is no limit on the number of connections
# using the class.
# 
# <connect freq> applies only to servers, and specifies the frequency 
# that the server tries to autoconnect. setting this to 0 will cause
# the server to attempt to connect repeatedly with no delay until the 
# <maximum links> condition is satisfied. This is a Bad Thing(tm).
# Note that times can be specified as a number, or by giving something
# like: 1 minutes 20 seconds, or 1*60+20.
#
# Recommended server classes:
# All your server uplinks you are not a hub for.
Class {
 # Server
 name = 90;
 pingfreq = 1 minutes 30 seconds;
 connectfreq = 5 minutes;
 maxlinks = 1;
 sendq = 9000000;
};
# All the leaf servers you hub for.
Class {
 # Leaf Server
 name = 80;
 pingfreq = 1 minutes 30 seconds;
 connectfreq = 5 minutes;
 maxlinks = 0;
 sendq = 9000000;
};

# Client {
#  host = "host";
#  ip = "127.0.0.0/8";
#  password = "password";
#  class = classname;
#  maxlinks = 3;
# };
#
# Everything in a Client block is optional.  If a username mask is
# given, it must match the client's username from the IDENT protocol.
# If a host mask is given, the client's hostname must resolve and
# match the host mask.  If a CIDR-style IP mask is given, the client
# must have an IP matching that range.  If maxlinks is given, it is
# limits the number of matching clients allowed from a particular IP
# address.
#
# Take the following class blocks only as a guide.
Class {
 # Locals
 name = 10;
 pingfreq = 1 minutes 30 seconds;
 sendq = 160000;
 maxlinks = 100;
};
Class {
 # America
 name = 2;
 pingfreq = 1 minutes 30 seconds;
 sendq = 80000;
 maxlinks = 5;
};
Class {
 # Other
 name = 1;
 pingfreq = 1 minutes 30 seconds;
 sendq = 160000;
 maxlinks = 400;
};
Class {
 # Opers
 name = 10;
 pingfreq = 1 minutes 30 seconds;
 sendq = 160000;
 maxlinks = 10;

 # For connection classes intended for operator use, you can specify
 # privileges used when the Operator block (see below) names this
 # class.  The local (aka globally_opered) privilege MUST be defined
 # by either the Class or Operator block.  The following privileges
 # exist:
 #
 # local (or propagate, with the opposite sense)
 # whox  (log oper's use of x flag with /WHO)
 # display (oper status visible to lusers)
 # chan_limit (can join local channels when in
 #                              MAXCHANNELSPERUSER channels)
 # mode_lchan (can /MODE &channel without chanops)
 # deop_lchan (cannot be deopped or kicked on local channels)
 # walk_lchan (can forcibly /JOIN &channel OVERRIDE)
 # show_invis (see +i users in /WHO x)
 # show_all_invis (see +i users in /WHO x)
 # unlimit_query (show more results from /WHO)
 # local_kill (can kill clients on this server)
 # rehash (can use /REHASH)
 # restart (can use /RESTART)
 # die (can use /DIE)
 # local_jupe (not used)
 # set (can use /SET)
 # local_gline (can set a G-line for this server only)
 # local_badchan (can set a Gchan for this server only)
 # see_chan (can see users in +s channels in /WHO)
 # list_chan (can see +s channels with /LIST S, or modes with /LIST M)
 # wide_gline (can use ! to force a wide G-line)
 # see_opers (can see opers without DISPLAY privilege)
 # local_opmode (can use OPMODE/CLEARMODE on local channels)
 # force_local_opmode (can use OPMODE/CLEARMODE on quarantined local channels)
 # kill (can kill clients on other servers)
 # gline (can issue G-lines to other servers)
 # jupe_server (not used)
 # opmode (can use /OPMODE)
 # badchan (can issue Gchans to other servers)
 # force_opmode (can use OPMODE/CLEARMODE on quarantined global channels)
 # remoterehash (can issue remote rehash's)
 # check (can use /CHECK)
 # see_secret_chan (can see secret channels in WHOIS outputs)a
 # shun (can issue SHUNS to other servers)
 # local_shun (can set a SHUN for this server only)
 # wide_shun (can use ! to force a wide SHUN)
 # zline (can issue Z-lines to other servers)
 # local_zline (can set a Z-line for this server only)
 # wide_zline (can use ! to force a wide Z-line)
 # whois_notice (can use whois notice oper mode)
 # hide_idle (can use hide idle usermode)
 # xtraop (can use xtra op oper mode)
 # hide_channels (can use hide channels usermode)
 #
 #
 #
 # For global opers (with propagate = yes or local = no), the default
 # is to grant all of the above privileges EXCEPT walk_lchan,
 # unlimit_query, set, badchan, local_badchan and apass_opmode.
 # For local opers, the default is to grant ONLY the following
 # privileges:
 #  chan_limit, mode_lchan, show_invis, show_all_invis, local_kill,
 #  rehash, local_gline, local_jupe, local_opmode, whox, display,
 #  force_local_opmode
 # Any privileges listed in a Class block override the defaults.

 local = no;
};


# [Client]
#
# To allow clients to connect, they need authorization. This can be
# done based on hostmask, address mask, and/or with a password.
# With intelligent use of classes and the maxconnections field in the
# Client blocks, you can let in a specific domain, but get rid of all other
# domains in the same toplevel, thus setting up some sort of "reverse
# Kill block".
# Client {
#  host = "user@host";
#  ip = "user@ip";
#  password = "password";
#  class = classname;
# };
#
# Technical description (for examples, see below):
# For every connecting client, the IP address is known.  A reverse lookup
# on this IP-number is done to get the (/all) hostname(s).
# Each hostname that belongs to this IP-number is matched to <hostmask>,
# and the Client {} is used when any matches; the client will then show
# with this particular hostname.  If none of the hostnames match, then
# the IP-number is matched against the <IP mask ...> field, if this matches
# then the Client{} is used nevertheless and the client will show with the
# first (main) hostname if any; if the IP-number did not resolve then the
# client will show with the dot notation of the IP-number.
# There is a special case for the UNIX domain sockets and localhost connections
# though; in this case the <IP mask ...> field is compared with the
# name of the server (thus not with any IP-number representation). The name
# of the server is the one returned in the numeric 002 reply, for example:
# 002 Your host is 2.undernet.org[jolan.ppro], running version ...
# Then the "jolan.ppro" is the name used for matching.
# Therefore, unix domain sockets, and connections to localhost would
# match this block:
# host = "*@jolan.ppro";
#
# This is the "fallback" entry. All .uk, .nl, and all unresolved are
# in these two lines.
# By using two different lines, multiple connections from a single IP
# are only allowed from hostnames which have both valid forward and
# reverse DNS mappings.
Client
{
 class = 1;
 ip = "*@*";
 maxlinks = 2;
};

Client
{
 class = 1;
 host = "*@*";
 maxlinks = 2;
};
# If you don't want unresolved dudes to be able to connect to your
# server, do not specify any "ip = " settings.
#
# Here, take care of all American ISPs.
Client
{
 host = "*@*.com";
 class = 2;
 maxlinks = 2;
};

Client
{
 host = "*@*.net";
 class = 2;
 maxlinks = 2;
};
# Now list all the .com / .net domains that you wish to have access...
# actually it's less work to do it this way than to do it the other
# way around - K-lining every single ISP in the US.
# I wish people in Holland just got a .nl domain, and not try to be
# cool and use .com...
Client { host = "*@*.wirehub.net"; class = 1; maxlinks=2; };
Client { host = "*@*.planete.net"; class = 1; maxlinks=2; };
Client { host = "*@*.ivg.com"; class = 1; maxlinks=2; };
Client { host = "*@*.ib.com"; class = 1; maxlinks=2; };
Client { host = "*@*.ibm.net"; class = 1; maxlinks=2; };
Client { host = "*@*.hydro.com"; class = 1; maxlinks=2; };
Client { host = "*@*.nl.net"; class = 10; maxlinks=2; };

# You can request a more complete listing, including the "list of standard
# Kill blocks" from the Routing Committee; it will also be sent to you if
# you apply for a server and get accepted.
#
# Ourselves - this makes sure that we can get in, no matter how full
# the server is (hopefully).
Client
{
 host = "*@*.london.ac.uk";
 ip = "*@193.37.*";
 class = 1;
 # A maxlinks of over 5 will automatically be glined by O3 on AfterNET
 maxlinks = 5;
};

# You can put an expression in the maxlinks value, which will make ircd
# only accept a client when the total number of connections to the network
# from the same IP number doesn't exceed this number.
# The following example would accept at most one connection per IP number
# from "*.swipnet.se" and at most two connections from dial up accounts
# that have "dial??.*" as host mask:
# Client {
#  host = "*@*.swipnet.se";
#  maxlinks = 1;
#  class = 1;
# };
# Client {
#  host = "*@dial??.*";
#  maxlinks = 2;
#  class = 1;
# };
#
# If you are not worried about who connects, this line will allow everyone
# to connect.
Client {
 host = "*@*";
 ip = "*@*";
 class = 1;
 maxlinks = 2;
};


# [motd]
#
# It is possible to show a different Message of the Day to a connecting
# client depending on its origin.
# motd {
#  # Note: host can also be a classname.
#  host = 1;
#  file = "path/to/motd/file";
# };
#
# More than one host = "mask"; entry may be present in one block; this
# has the same effect as one Motd block for each host entry, but makes
# it easier to update the messages's filename.
#
# DPATH/net_com.motd contains a special MOTD where users are encouraged
# to register their domains and get their own client{} lines if they're in
# Europe, or move to US.UnderNet.org if they're in the USA.
motd {
 host = "*.net";
 file = "net_com.motd";
};
motd {
 host = "*.com";
 file = "net_com.motd";
};
motd {
 host = "America";
 file = "net_com.motd";
};

# A different MOTD for ourselves, where we point out that the helpdesk
# better not be bothered with questions regarding irc...
motd {
 host = "*.london.ac.uk";
 file = "london.motd";
};


# [Connect]
#
# You probably want your server connected to other servers, so your users
# have other users to chat with.
# IRC servers connect to other servers forming a network with a star or
# tree topology. Loops are not allowed.
# In this network, two servers can be distinguished: "hub" and "leaf"
# servers. Leaf servers connect to hubs; hubs connect to each other.
# Of course, many servers can't be directly classified in one of these
# categories. Both a fixed and a rule-based decision making system for
# server links is provided for ircd to decide what links to allow, what
# to let humans do themselves, and what links to (forcefully) disallow.
#
# The Connect blocks
# define what servers the server connect to, and which servers are
# allowed to connect.
#
# Connect {
#  name = "servername";
#  host = "hostnameORip";
#  password = "passwd";
#  port = portno;
#  class = classname;
#  maxhops = 2;
#  hub;
#  leaf = no;
#  autoconnect = no;
# };
#
# The "port" field defines the default port the server tries to connect
# to if an operator uses /connect without specifying a port. This is also
# the port used when the server attempts to auto-connect to the remote
# server. (See Class blocks for more informationa about auto-connects).
# You may tell ircu to not automatically connect to a server by adding
# "autoconnect = no;"; the default is to autoconnect.
#
# The maxhops field causes an SQUIT if a hub tries to introduce
# servers farther away than that; the element 'leaf;' is an alias for
# 'maxhops = 0;'.  The hub field limits the names of servers that may
# be introduced by a hub; the element 'hub;' is an alias for
# 'hub = "*";'.
#
# Our primary uplink.
Connect {
 name = "Amsterdam.EU.AfterNET.Org";
 host = "1.2.3.4";
 password = "passwd";
 port = 4400;
 class = 90;
 hub;
};


# [crule]
#
# For an advanced, real-time rule-based routing decision making system
# you can use crule blocks. For more information, see doc/readme.crules.
# If more than one server mask is present in a single crule, the rule
# applies to all servers.
# CRULE
# {
#  server = "servermask";
#  rule = "connectrule";
#  # Setting all to yes makes the rule always apply. Otherwise it only
#  # applies to autoconnects.
#  all = yes;
# };
CRULE
{
 server = "*.US.AfterNET.Org";
 rule = "connected(*.US.AfterNET.Org)";
};
CRULE
{
 server = "*.EU.AfterNET.Org";
 rule = "connected(Amsterdam.EU.*)";
};

# The following block is recommended for leaf servers:
CRULE
{
 server = "*";
 rule = "directcon(*)";
};


# [Operator]
#
# Inevitably, you have reached the part about "IRC Operators". Oper status
# grants some special privileges to a user, like the power to make the
# server break or (try to) establish a connection with another server,
# and to "kill" users off IRC.
# I can write many pages about this; I will restrict myself to saying that
# if you want to appoint somebody as IRC Operator on your server, that
# person should be aware of his/her responsibilities, and that you, being
# the admin, will be held accountable for their actions.
#
# There are two sorts of IRC Operators: "local" and "global". Local opers
# can squit, connect and kill - but only locally: their +o user mode
# is not not passed along to other servers. On Undernet, this prevents
# them from using Uworld as well.
#
# More than one host = "mask"; entry may be present in one block; this
# has the same effect as one Operator block for each host entry, but
# makes it easier to update operator nicks, passwords, classes, and
# privileges.
#
# Operator {
#  host = "host/IP mask";
#  name = "opername";
#  password = "encryptedpass";
#  flags = "oper flags";
#  class = classnumber;
#  # You can also set any operator privilege; see the Class block
#  # documentation for details.  A privilege defined for a single
#  # Operator will override the privilege settings for the Class
#  # and the default setting.
# };
#
#
# By default, the password is hashed using the system's native crypt()
# function.  Other password mechanisms are available; the umkpasswd
# utility from the ircd directory can hash passwords using those
# mechanisms.  If you use a password format that is NOT generated by
# umkpasswd, ircu will not recognize the oper's password.
#
# There are 7 types of flags currently which will only work if the OPERFLAGS
# is enabled. When the feature is disabled, the flags are ignored.
#
# o - Local Operator
# O - Global Operator
# A - IRC Administrator
# r - O:Line can be used from remote servers
# W - Allowed to set user mode +W (whois notice)
# I - Allowed to set user mode +I (hide idle)
# n - Allowed to set user mode +n (hide channels)
# X - Allowed to set user mode +X (requires F:OPER_XTRAOP:TRUE)
#
# YOU NEED ATLEAST ONE FLAG!
#
Operator {
 local = no;
 host = "*@*.cs.vu.nl";
 password = "VRKLKuGKn0jLt";
 flags = "O";
 name = "Niels";
 class = 1;
};
Operator {
 host = "*@*.uu.net";
 password = "$PLAIN$notencryptedpass";
 name = "Niels";
 flags = "O";
 class = 10;
};

# Note that the <connection class> is optional, but leaving it away
# puts the opers in class "default", which usually only accepts one
# connection at a time.  If you want users to Oper up more then once per
# block, then use a connection class that allows more then one connection,
# for example (using class Local as in the example above):
#
# Once you OPER your connection class changes no matter where you are or
# your previous connection classes.  If the defined connection class is
# Local for the operator block, then your new connection class is Local.
#
# If you want to use a more secure password authentication system then
# Generate a 1024bit RSA key, specify the path to the key as the password
# and add R as the oper flag. This will use the CHALLENGE system instead of
# /OPER. See doc/challenge.txt for more information.
#
Operator {
  host = "*@somehost.co.nz";
  password = "/home/irc/keys/vulcan.key";
  name = "vulcan";
  flags = "RO";
  class = 10;
};


# [UWorld]
#
# One of the many nice features in Nefarious is "Uworld", a program
# connected to the net as a server. This allows it to broadcast any mode
# change, thus allowing opers to, for example, "unlock" a channel that
# has been taken over.
# There is only one slight problem: the TimeStamp protocol prevents this.
# So there is a configuration option to allow them anyway from a certain
# server.
#
# UWorld {
#  # The servername or wildcard mask for it that this applies to.
#  name = "relservername";
# };
#
# You may have have more than one name listed in each block.
#
# Note: (1) These lines are agreed on by every server admin;
# (2) These lines must be the same on every single server, or results
# will be disasterous; (3) This is a useful feature, not something that
# is a liability and abused regularly (well... :-)
#
# If your server starts on a bit larger network, you'll probably get
# assigned one or two uplinks to which your server can connect.
# If your uplink(s) also connect to other servers than yours (which is
# probable), you need to define your uplink as being allowed to "hub".
# See the Connect block documentation for details on how to do that.
#
# Examples:
#
# UWorld {
#  name = "uworld.eu.undernet.org";
#  name = "uworld2.undernet.org";
#  name = "uworld.undernet.org";
#  name = "channels.undernet.org";
#  name = "channels2.undernet.org";
#  name = "channels3.undernet.org";
#  name = "channels4.undernet.org";
#  name = "channels5.undernet.org";
#  name = "channels6.undernet.org";
# };
#
# It is possible to Jupe nicks so that no user can use them. Opers
# cannot use them either. You can specify wildcards of * and ?.
#
# Examples:
#
# Jupe {
#  nick = "A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,{,|,},~,-,_,`";
#  nick = "EuWorld,UWorld,UWorld2";
#  nick = "login,afternet,protocol,pass,newpass,org";
#  nick = "StatServ,NoteServ";
#  nick = "ChanSvr,ChanSaver,ChanServ";
#  nick = "NickSvr,NickSaver,NickServ";
#  nick = "LPT?,COM?,AUX";
#  nick = "X?,O?,MemoServ";
# };
#


# [Kill]
#
# While running your server, you will most probably encounter individuals
# or groups of persons that you do not wish to have access to your server.
#
# For this purpose, the ircd understands "kill blocks". These are also
# known as K-lines, by virtue of the former config file format.
# Kill
# {
#   host = "user@host";
#   reason = "The reason the user will see";
# };
# It is possible to ban on the basis of the real name.
# It is also possible to use a file as comment for the ban, using
# file = "file":
# Kill
# {
#   realname = "realnametoban";
#   file = "path/to/file/with/reason/to/show";
# };
#
#
# The default reason is: "You are banned from this server"
# Note that Kill blocks are local to the server; if you ban a person or a
# whole domain from your server, they can get on IRC via any other server
# that doesn't have them Killed (yet).
#
# With a simple comment, using quotes:
#
# Kill { host = "*.au"; reason = "Please use a nearer server"; };
# Kill { host = "*.edu"; reason = "Please use a nearer server"; };
# 
# You can also kill based on username.
# Kill { username = "sub7"; realname = "s*7*"; reason = "You are infected with a Trojan"; };
# 
# The file can contain for example, a reason, a link to the
# server rules and a contact address.  Note the combination
# of username and host in the host field.
#
# Kill
# {
#  host = "*luser@unixbox.flooder.co.uk";
#  file = "kline/youflooded.txt";
# };
# 
# IP-based kill lines apply to all hosts, even if an IP address has a
# properly resolving host name.
#
# Kill
# {
#  host = "192.168.*";
#  file = "klines/martians";
# };
# 
# The realname field lets you ban by realname...
#
# Kill
# {
#  realname = "*sub7*";
#  reason = "You are infected with a Trojan";
# };
# 
# Additionally, you may specify a hostmask prefixed with $V to indicate
# a match should be performed against the CTCP version of the user rather
# than the host/IP.
#
# Kill
# {
#  version = "*iroffer*";
#  reason = "You are using a disallowed chat client version. Either upgrade or get a new client.";
# };
#

 
# [Except]
#
# These can be used to exempt a user from Kill Blocks, GLINE's, ZLINE's and
# SHUN's
#
# The syntax for Except blocks is:
#
# Except {
#   mask = "<mask>";
#   flags = "<flags>";
#
# <mask>  is a ident@ip/host/cidr mask that is to match the user to be
#         exempted
# <flags> is oone of the following flags to specify what the exempt is to
#         match
#
# k       Excpet affecks K/k:Lines
# g       Except affects GLINE's
# z       Except affects ZLINE's
# s       Except affects SHUN's
# S       Except affects Spam Filters
#
# Example:
#
# Except {
#   mask = "*@*.afternet.org";
#   flags = "kgzs";
# };
#


# [Command]
#
# These are lines intended to improve the generic irc users ability to
# use network services. Each line sets up a /<service> alias so that
# users may type that instead of a full /msg command.
#
# for example.. adding:
## Command {
##   cmd = "X2";
##   service = "X2@X2.AfterNET.Services";
## };
# would result in commands like this being possible
## /X2 HELP
#
# Command {
#   cmd = "<name of command/service>";
#   service = "<target>";
#   prefix = "<anything to prepend to message>";
# };
#


# [Forward]
# These blocks will enable the server to forward any messages which
# are prefixed and specific with a b:line. This will allow users to
# use the services without the services being in channel.
#
# Forward {
#   "<prefix>" = "<server>";
# };
#
# Forward {
#   "!" = "services.network.org";
#   "?" = "services.network.org";
# };
#
# Any channel messages prefixed with a ? or a ! would be sent to
# services.network.org in the above examples.


# [Redirect]
#
# These are redirection lines, when a client connects and his/her host
# matches a q:line then a 010 reply is sent with the redir server and
# port.
#
# Redirect {
#   mask = "<mask>";
#   server = "<redirection server>";
#   port = "<redirection port>";
# };
#
#
# Redirect {
#   mask = "*.aol.com";
#   server = "irc.aol.com";
#   port = "6667";
# };
#


# [Spoofhost]
#
# Spoofhost {
#   spoof = "<spoof host>";
#   pass = "<password>";
#   hostmask = "<*.host.cc|a.b.c.*|CIDR>";
#   ident = "<ident>";
# };
#
# <spoof>       A hostname to be spoofed
# <password>    A password for this spoof host. Used if SETHOST_USER is enabled.
# <hostmask>    A hostmask for matching against users that are to be auto
#               spoofed. Used if SETHOST_AUTO is enabled. Can be of form:
#               host.domain.cc, 127.0.0.1 or 127.0.0.0/24, supports wildcards
#               for non-CIDR.
# <ident>       A mask for matching against the user's ident reply.
#


# [Quarantine]
#
# This allows you (the admin) to disallow the usage of /OPMODE and
# /CLEARMODE on certain sensitive channels. Opers trying to do that
# will receive a short notice. Depending on the setting of
# OPER_FORCE_OPMODE, OPER_FORCE_LOPMODE and LOCOP_FORCE_LOPMODE,
# global/local opers may override these lines by prefixing the
# channel name with an exclamation mark ('!')
#
# Quarantine {
#   "#shells" = "Thou shalt not support the h4><0rz";
#   "&kiddies" = "They can take care of themselves";
# };
#


# [DNSBL]
#
# This allows you (the admin) to prevent clients connecting who are listed
# on DNS blacklists. Their connection will be rejected during the connection
# process along with the name and url you give for the DNSBL they have
# been matched on.
#
# DNSBL {
#   server = "<dnsbl.site.org>";
#   name = "<name>";
#   flags = "<flags>";
#   replies = "<replies/mask>";
#   reply = "<rejection message>";
#   rank = "<rank>";
# }
#
#
# Flags:
#
# Bitmask DNSBL:  b - See your DNSBL provider as to if you should use this or not.
# Reply DNSBL:    r - See your DNSBL provider as to if you should use this or not, this
#                     type is normally the default type for most DNSBL's.
# Allow Connect:  a - Allow the client to connect anyway. This could be used with a
#                     DNSBL whitelist. This could also be used to allow people in but
#                     mark their hosts so that channel ops can choose weather they want
#                     them in thier channel or not.
# Deny Connect:   d - If the user is found on this dnsbl then they cant connect, even if
#                     they are allowed on another X:Line.
# Mark Hostname:  m - Mark the hostname of a skipped client.
#
# 
# The name option is used for the Mark hostname flag, this must contain hostname
# valid characters only, ie NO spaces. With REPLY DNSBL's you need to list the
# replies in a comma seperate list. See below for an example. With BITMASK DNSBL's
# just again specify the replies you need to match against. The server will sum
# them up and match them against the DNSBL reply. It is highly recomended that
# you place the rejection message in "quotes". Rejection messages are limited
# in length, currently they cant be all that long but that is being worked on. The
# rejected users nick, username, ip, and host can be placed into the rejection
# message by using these codes:
#
# %n - Nickname
# %u - Username
# %h - Hostname
# %i - IP Address
#
# The rank number must be unique over all DNSBL blocks, the higher the number- the more
# rank it has. The highest ranking DNSBL block which is matched against a user will
# get its name marked in the hostname.
#
# Example:
#
# DNSBL {
#   server = "dnsbl.sorbs.net";
#   name = "sorbs.net";
#   flags = "r";
#   replies = "1,2,3,4";
#   reply = "%n!%u@%h Found On Sorbs DNSBL http://www.dnsbl.us.sorbs.net/cgi-bin/lookup?IP=%i";
#   rank = "1";
# }
#
# This will reject clients who get a return addresses of 1,3 and 4 off
# dnsbl.sorbs.net. Sample rejection message:
#
# "bloggs!someident@google.com Found On Sorbs DNSBL http://www.dnsbl.us.sorbs.net/cgi-bin/lookup?IP=111.222.111.222"
#
# BITMASK Example:
#
# DNSBL {
#   server = "dnsbl.dnsbl.net";
#   name = "dnsbl.net";
#   flags = "b";
#   replies = "1,3,5";
#   reply = "%n!%u@%h Found On DNSBL";
#   rank = "2";
# };
#
# I reccomend you take advantage of ircd.conf includes and list your X:Lines in
# a seperate file as it could be quite a large list.
#
# Notes: MAKE SURE you read the DNSBL website before you go ahead and use it
# as they may have rules for large sites/servers who use them. If you do not
# wish to use DNSBL checking then simply do not set any X:lines. I only
# reccomend that you use one DNSBL, due to the amount of time it will take to
# connect with multiple DNSBL's.


# [WebIRC]
#
# These blocks allow you to run a CGI:IRC client on your website without
# having to set clone exceptions for your websites hostname on your IRCd.
# CGI:IRC will send a WEBIRC command along with the clients hostname, ip and
# W:Line password. The password needs to be encrypted like O:line passwords.
# When the IRCd recieves the command instead of using the hostname of the IRCd
# the hostname sent in WEBIRC will be set. All this is done before the client
# enters the network completly. Please rememeber to enclose the description
# using quotes otherwise things will break.
#
# Available Flags:
# m - Marks each client connected via the W:line using the provided description.
# s - Sets the ident specified in the ident field for each WEBIRC client.
# u - Uses the ident from USER that the WEBIRC client sends.
#
# Note: Do not use both s and u, only choose one of them.
#
#
# WebIRC {
#   mask = "*@afternet.org";
#   pass = "VRKLKuGKn0jLs";
#   flags = "sm";
#   ident = "cgiirc";
#   desc = "AfterNET CGI:IRC";
# };
#


# [SFilter]
#
# These blocks allow you to filter PRIVMSG's, NOTICE's, TOPIC's and AWAY's for
# Spam. The filtering is doing using regular expressions so please be careful.
#
# SFilter {
#   regex = "<regex>";                      # - PCRE format regular expression.
#   rtype = "<watch flags>";                # - See below for a list.
#   action = "<action flags>";              # - See below for a list.
#   reason = "<reason>";
#   channel = "<optional alert channel>";   # - Requires the C action flag.
#   length = 3600;                          # - Only applies to glines, zlines and shuns.
# };
#
# Available Watch Flags
# n - Notices.
# N - Channel Notices.
# p - Privmsgs.
# C - Channel Privmsgs.
# q - Quits.
# P - Parts.
# d - DCCs.
# a - Away messages.
# t - Topics.
# u - Connects (nick!user@host:gecos).
# i - Nickname changes.
#
# Available Action Flags
# a - Auth, if added logged in clients will be exempt from the filter.
# C - Channel Alert, if added filter matches will be sent to what is set in the
#     SFilter channel setting. If the channel setting is missing then the setting
#     for the Feature FILTER_DEFAULT_CHANNAME will be used.
# S - Server Alert
# k - Kill, will kill anyone who matches the filter line.
# g - Gline, will gline anyone who matches the filter line. The length can be set
#     in seconds via the length.
# z - Zline, will zline anyone who matches the filter line. The length can be set
#     in seconds via the length setting. This zlines *@ip. You do not need the i
#     action flag.
# s - Shun, will shun anyone who matches the filter line. The length can be set
#     in seconds via the length setting.
# i - Uses the clients IP to in a G/Zline or shun.
# b - Block, will stop the PRIVMSG/NOTICE/TOPIC/AWAY from going through.
# n - Notify, will notify the person matching the filter line saying they have
#     matched a filter line and the message has been denyed.
# m - Mark, will mark the client as being a spam source.
# K - Kick, will kick the user triggering the Spam Filter. The kick reason given
#     will be the reason set in the Spam Filter. This Flag will only work with the
#     N and C watch flags.
# o - Ops/Halfops, if added it will exempt halfops and ops from being any checks
#     which have a channel target. They of course need to be an op or halfop to be
#     exempt from the check. Be careful with this flag.
# v - Voice, if added it will exempt voiced users from any checks which have a
#     channel target. If channels have auto voice enabled then this will mean
#     spammers can still spam the channel.
#
# Notes:
# - Shuns and Glines will be set using *@hostname. If you want *@ip then set the
#   i action flag. Zlines will always set *@ip.
# - If you do not specify a length then the default length from the feature
#   FILTER_DEFAULT_LENGTH will be used.
# - You cannot use the b block flag in a SFilter block that uses the u connects
#   flag. You will need to use a kill flag to block them.
#


# [Port]
#
# When your server gets more full, you will notice delays when trying to
# connect to your server's primary listening port. It is possible via the
# Port lines to specify additional ports for the ircd to listen to.
# De facto ports are: 6667 - standard; 6660-6669 - additional client
# ports;
# Undernet uses 4400 for server listener ports.
# These are just hints, they are in no way official IANA or IETF policies.
# IANA says we should use port 194, but that requires us to run as root,
# so we don't do that.
#
#
# Port {
#  port = number;
#  mask = "ipmask";
#  # Use this to control the interface you bind to.
#  vhost = "virtualhostip";
#  # Setting to yes makes this server only.
#  server = yes;
#  # Setting to yes makes the port "hidden" from stats.
#  hidden = yes;
#  # Setting to yes makes the port accept SSL connections from clients.
#  crypt = yes;
#  # Setting to yes makes the port exempt from connection restrictions
#  # during a timed /restart or /die.
#  exempt = yes;
# };
#
# The mask setting allows you to specify a range of IP addresses that
# you will allow connections from. This should only contain IP addresses
# and '*' if used. This field only uses IP addresses. This does not use
# DNS in any way so you can't use it to allow *.nl or *.uk. Attempting
# to specify anything other than numbers, dots and stars [0-9.*] will result
# in the port allowing connections from anyone.
#
# The interface setting allows multiply homed hosts to specify which
# interface to use on a port by port basis, if an interface is not specified
# the default interface will be used. The interface MUST be the complete
# IP address for a real hardware interface on the machine running ircd.
# If you want to use virtual hosting *YOU* *MUST* *USE* *THIS* otherwise it
# WILL bind to all interfaces - not what most people seem to expect.
#
# Examples:
#
# Port {
#  server = yes;
#  port = 4400;
# };
#
# The following are normal client ports
# Port { port = 6667; };
# Port { port = 6668; };
# Port {
#  # This only accepts clients with IPs like 192.168.*.
#  mask = "192.168.*";
#  port = 6666;
#  # Allows your opers to connect during a timed /restart or /die.
#  exempt = yes;
# };
#
# This is a hidden client port, listening on 168.8.21.107.
# Port {
#  vhost = "168.8.21.107";
#  hidden = yes;
#  port = 7000;
# };
#


# [Features]
#
# IRC servers have a large number of options and features.  Most of these
# are set at compile time through the use of #define's--see "make config"
# for more details--but we are working to move many of these into the
# configuration file.  Features let you configure these at runtime.
# You only need one feature block in which you use
# "featurename" = "value1" , "value2", ..., "valuen-1", "valuen";
#
# The entire purpose of Features are so that you do not have to recompile
# the IRCD everytime you want to change a feature.  All of the features
# are listed below, and at the bottom is how to set logging.
#
# A Special Thanks to Kev for writing the documentation of F:lines.  It can
# be found at doc/readme.features and the logging documentation can be
# found at doc/readme.log.  The defaults used by the Undernet network are
# below.
#
Features
{
# These log features are the only way to get certain error messages
# (such as when the server dies from being out of memory).  For more
# explanation of how they work, see doc/readme.log.
 "LOG" = "SYSTEM" "FILE" "ircd.log";
 "LOG" = "SYSTEM" "LEVEL" "CRIT";
#
# Server Settings
#
#  "DOMAINNAME" = "<obtained from /etc/resolv.conf by ./configure>";
#  "RELIABLE_CLOCK" = "FALSE";
#  "BUFFERPOOL" = "27000000";
#  "HAS_FERGUSON_FLUSHER" = "FALSE";
#  "CLIENT_FLOOD" = "1024";
#  "SERVER_PORT" = "4400";
#  "NODEFAULTMOTD" = "TRUE";
#  "MOTD_BANNER="TRUE";
#  "KILL_IPMISMATCH" = "FALSE";
#  "IDLE_FROM_MSG" = "TRUE";
#  "HUB" = "FALSE";
#  "WALLOPS_OPER_ONLY" = "FALSE";
#  "NODNS" = "FALSE";
#  "RANDOM_SEED" = "<you should set one explicitly>";
#  "DEFAULT_LIST_PARAM" = "TRUE";
#  "NICKNAMEHISTORYLENGTH" = "800";
#  "TIME_IN_TIMEOUT" = "FALSE";
#  "KILLCHASETIMELIMIT" = "30";
#  "MAXCHANNELSPERUSER" = "10";
#  "AVEXCEPTLEN" = "40";
#  "MAXEXCEPTS" = "45";
#  "NICKLEN" = "15";
#  "CHANNELLEN" = "200";
#  "AVBANLEN" = "40";
#  "MAXBANS" = "45";
#  "MAXSILES" = "15";
#  "HANGONGOODLINK" = "300";
#  "HANGONRETRYDELAY" = "10";
#  "CONNECTTIMEOUT" = "90";
#  "TIMESEC" = "60";
#  "MAXIMUM_LINKS" = "1";
#  "PINGFREQUENCY" = "120";
#  "CONNECTFREQUENCY" = "600";
#  "DEFAULTMAXSENDQLENGTH" = "40000";
#  "SHUNMAXUSERCOUNT" = "20";
#  "GLINEMAXUSERCOUNT" = "20";
#  "MPATH" = "ircd.motd";
#  "QPATH" = "ircd.quotes";
#  "EPATH" = "ircd.rules";
#  "OMPATH" = "ircd.opermotd";
#  "RPATH" = "remote.motd";
#  "PPATH" = "ircd.pid";
#  "TPATH" = "ircd.tune";
#  "VIRTUAL_HOST" = "FALSE";
#  "TOS_SERVER" = "0x08";
#  "TOS_CLIENT" = "0x08";
#  "POLLS_PER_LOOP" = "200";
#  "IRCD_RES_TIMEOUT" = "4";
#  "IRCD_RES_RETRIES" = "2";
#  "AUTH_TIMEOUT" = "9";
#  "NICK_DELAY" = "30";
#  "POLICY_NOTICE" = "TRUE";
#  "TARGET_LIMITING" = "TRUE";
#  "EXTENDED_ACCOUNTS" = "TRUE";
#  "NETWORK_REHASH" = "FALSE";
#  "NETWORK_RESTART" = "FALSE";
#  "NETWORK_DIE" = "FALSE";
#  "HELP_PACE" = "5";
#  "NOIDENT" = "FALSE";
#  "IPCHECK" = "TRUE";

#
# Commands
#
#  "QUOTES" = "TRUE";
#  "RULES" = "TRUE";
#  "OPERMOTD" = "TRUE";

#
#  Spam Filter Settings
#
#  "FILTER_DEFAULT_CHANNAME" = "#opers";
#  "FILTER_ALERT_USEMSG" = "FALSE";
#  "FILTER_DEFAULT_LENGTH" = "3600";

#
# Login On Connect
#
#  "LOGIN_ON_CONNECT" = "FALSE";
#  "LOC_DEFAULT_SERVICE" = "authserv";

#
# User Modes
#
#  "DEFAULT_UMODE" = "+";

#
# Hidden Hosts Settings
#
#  "HOST_HIDING" = "TRUE";
#  "HOST_HIDING_STYLE" = "1";
#  "HOST_HIDING_KEY1" = "aoAr1HnR6gl3sJ7hVz4Zb7x4YwpW";
#  "HOST_HIDING_KEY2" = "sdfjkLJKHlkjdkfjsdklfjlkjKLJ";
#  "HOST_HIDING_KEY3" = "KJklJSDFLkjLKDFJSLKjlKJFlkjS";
#  "HOST_HIDING_PREFIX" = "AfterNET";
#  "OPERHOST_HIDING" = "TRUE";
#  "HIDDEN_HOST" = "Users.AfterNET.Org";
#  "HIDDEN_OPERHOST" = "Opers.AfterNET.Org";
#  "HIDDEN_IP" = "127.0.0.1";

# Autojoin Settings
#
# ALWAYS PREFIX HASHES WITH A BACKSLASH IN AUTOJOIN FEATURES!
#
#  "AUTOJOIN_USER" = "FALSE";
#  "AUTOJOIN_USER_CHANNEL" = "\#evilnet";
#  "AUTOJOIN_USER_NOTICE" = "TRUE";
#  "AUTOJOIN_USER_NOTICE_VALUE" = "*** Notice -- You are now being autojoined into \#evilnet";
#  "AUTOJOIN_ADMIN" = "FALSE";
#  "AUTOJOIN_ADMIN_CHANNEL" = "\#admin";
#  "AUTOJOIN_ADMIN_NOTICE" = "TRUE";
#  "AUTOJOIN_ADMIN_NOTICE_VALUE" = "*** Notice -- You are now being autojoined into admin channel \#admin";
#  "AUTOJOIN_OPER" = "FALSE";
#  "AUTOJOIN_OPER_CHANNEL" = "\#opers";
#  "AUTOJOIN_OPER_NOTICE" = "TRUE";
#  "AUTOJOIN_OPER_NOTICE_VALUE" = "*** Notice -- You are now being autojoined into oper channel \#opers";

#
# Oper Settings
#
#  "REMOTE_OPER" = "FALSE";
#  "CHECK_EXTENDED" = "TRUE";
#  "MAX_CHECK_OUTPUT" = "1000";
#  "CONFIG_OPERCMDS" = "FALSE";
#  "OPERFLAGS" = "FALSE";
#  "CONNEXIT_NOTICES" = "FALSE";

#
# WHOIS Settings
#
#  "WHOIS_OPER" = "is an IRC Operator";
#  "WHOIS_ADMIN" = "is an IRC Administrator";
#  "WHOIS_SERVICE" = "is a Network Service";

#
# ALIST Settings
#
#  "SET_ACTIVE_ON_CREATE" = "TRUE";
#  "DEF_ALIST_LIMIT" = "30";
#  "ALIST_SEND_FREQ" = "300";
#  "ALIST_SEND_DIFF" = "600";

#
# SETHOST Settings
#
#  "SETHOST" = "TRUE";
#  "SETHOST_USER" = "TRUE";
#  "SETHOST_AUTO" = "TRUE";
#  "SETHOST_FREEFORM" = "FALSE";

#
# Channel Settings
#
#  "TOPIC_BURST" = "TRUE";
#  "HOST_IN_TOPIC" = "TRUE";
#  "AUTOCHANMODES" = "FALSE";
#  "AUTOCHANMODES_LIST" = "nt";
#  "LOCAL_CHANNELS" = "TRUE";
#  "EXCEPTS" = "FALSE";
#  "BREAK_P10" = "FALSE";
#  "FLEXABLEKEYS" = "FALSE";
#  "NOTHROTTLE" = "FALSE";
#  "CREATE_CHAN_OPER_ONLY" = "FALSE";
#  "ANNOUNCE_INVITES" = "TRUE";
#  "HALFOPS" = "FALSE";
#  "BADCHAN_REASON" = "This Channel Has Been Banned";
#  "MAX_BOUNCE" = "5";


#
# Server Passwords
#
#  "RESTARTPASS" = "";
#  "DIEPASS" = "";

#
# DNSBL Checks
#
#  "DNSBL_CHECKS" = "FALSE";
#  "DNSBL_EXEMPT_CLASS" = "0";
#  "DNSBL_LOC_EXEMPT" = "FALSE";
#  "DNSBL_LOC_EXEMPT_N_ONE" = "If you have an account with %s services then you can bypass the dnsbl ban by logging in like this" = " (where Account is your account name and Password is your password.";
#  "DNSBL_LOC_EXEMPT_N_TWO" = "Type \002/QUOTE PASS AuthServ Account " = "Password\002 to connect";
#  "EXEMPT_EXPIRE" = "172800";
#  "DNSBL_MARK_FAKEHOST" = "TRUE";

#
# CTCP Version Checks
#
#  "CTCP_VERSIONING" = "FALSE";
#  "CTCP_VERSIONING_KILL" = "FALSE";
#  "CTCP_VERSIONING_CHAN" = "FALSE";
#  "CTCP_VERSIONING_CHANNAME" = "#opers";
#  "CTCP_VERSIONING_USEMSG" = "FALSE";
#  "CTCP_VERSIONING_NOTICE" = "*** Checking your client version";

#
# Raw Replies
#
#  "ERR_OPERONLYCHAN" = "Cannot join channel (+O)";

#
# Server Security Settings
#
#  "HIS_EXCEPTWHO" = "TRUE";
#  "HIS_IRCOPS" = "TRUE";
#  "HIS_IRCOPS_SERVERS" = "TRUE";
#  "HIS_MAP" = "TRUE";
#  "HIS_MAP_SCRAMBLED" = "TRUE";
#  "HIS_SNOTICES" = "TRUE";
#  "HIS_SNOTICES_OPER_ONLY" = "TRUE";
#  "HIS_SNOTICES_OPER_AND_BOT" = "FALSE";
#  "HIS_DESYNCS" = "TRUE";
#  "HIS_DEBUG_OPER_ONLY" = "TRUE";
#  "HIS_WALLOPS" = "TRUE";
#  "HIS_LINKS" = "TRUE";
#  "HIS_LINKS_SCRAMBLED" = "TRUE";
#  "HIS_TRACE" = "TRUE";
#  "HIS_SHUN_REASON" = "TRUE";
#  "HIS_STATS_MODULES" = "TRUE";
#  "HIS_STATS_LINKS" = "TRUE";
#  "HIS_STATS_MAPPINGS" = "TRUE";
#  "HIS_STATS_CONNECT" = "TRUE";
#  "HIS_STATS_GLINES" = "TRUE";
#  "HIS_STATS_KLINES" = "TRUE";
#  "HIS_STATS_FILTERS" = "TRUE";
#  "HIS_STATS_ACCESS" = "TRUE";
#  "HIS_STATS_HISTOGRAM" = "TRUE";
#  "HIS_STATS_COMMANDS" = "TRUE";
#  "HIS_STATS_OPERATORS" = "TRUE";
#  "HIS_STATS_PORTS" = "TRUE";
#  "HIS_STATS_QUARANTINES" = "TRUE";
#  "HIS_STATS_REDIRECTIONS" = "TRUE";
#  "HIS_STATS_USAGE" = "TRUE";
#  "HIS_STATS_CRULES" = "TRUE";
#  "HIS_STATS_EXCEPTIONS" = "TRUE";
#  "HIS_STATS_ENGINE" = "TRUE";
#  "HIS_STATS_SPOOFHOSTS" = "TRUE";
#  "HIS_STATS_SHUNS" = "TRUE";
#  "HIS_STATS_LOCALS" = "TRUE";
#  "HIS_STATS_MOTDS" = "TRUE";
#  "HIS_STATS_UPTIME" = "FALSE";
#  "HIS_STATS_UWORLD" = "TRUE";
#  "HIS_STATS_VSERVERS" = "TRUE";
#  "HIS_STATS_WEBIRCS" = "TRUE";
#  "HIS_STATS_USERLOAD" = "FALSE";
#  "HIS_STATS_MEMUSAGE" = "TRUE";
#  "HIS_STATS_DNSBLS" = "TRUE";
#  "HIS_STATS_CLASSES" = "TRUE";
#  "HIS_STATS_MEMORY" = "TRUE";
#  "HIS_STATS_ZLINES" = "TRUE";
#  "HIS_WHOIS_SERVERNAME" = "TRUE";
#  "HIS_WHOIS_IDLETIME" = "TRUE";
#  "HIS_WHOIS_LOCALCHAN" = "TRUE";
#  "HIS_WHO_SERVERNAME" = "TRUE";
#  "HIS_WHO_HOPCOUNT" = "TRUE";
#  "HIS_BANWHO" = "TRUE";
#  "HIS_KILLWHO" = "TRUE";
#  "HIS_HIDEWHO" = "TRUE";
#  "HIS_REWRITE" = "TRUE";
#  "HIS_REMOTE" = "1";
#  "HIS_SCRAMBLED_CACHE_TIME" = "604800";
#  "HIS_NETSPLIT" = "TRUE";
#  "HIS_GLINE" = "TRUE";
#  "HIS_SERVERNAME" = "*.Nefarious";
#  "HIS_SERVERINFO" = "evilnet development";
#  "HIS_URLSERVERS" = "http" = "//sourceforge.net/projects/evilnet/";
#  "NETWORK" = "Nefarious";
#  "URL_CLIENTS" = "http" = "//www.ircreviews.org/clients/";
#  "BADUSER_URL" = "http" = "//www.mirc.co.uk/help/servererrors.html";
};
